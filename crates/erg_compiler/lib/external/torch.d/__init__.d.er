.backends = pyimport "./backends"
.cuda = pyimport "./cuda"
.nn = pyimport "./nn"
.optim = pyimport "./optim"
.serialization = pyimport "./serialization"
.utils = pyimport "./utils"

{.load!; .save!;} = pyimport "./serialization"
{.manual_seed!;} = import "./random"

.Device = 'device': ClassType
.device: (type: Str) => .Device

.DType = 'dtype': ClassType
.dtype: (type: Str) => .DType

.UInt8 = 'uint8': ClassType
.Int8  = 'int8': ClassType
.Int16 = 'int16': ClassType
.Int32 = 'int32': ClassType
.Int64 = 'int64': ClassType
.Float16 = 'float16': ClassType
.Float32 = 'float32': ClassType
.Float64 = 'float64': ClassType
.Complex32 = 'complex32': ClassType
.Complex64 = 'complex64': ClassType
.Complex128 = 'complex128': ClassType

.Size: ClassType
.Tensor!: (T: Type, Shape: [Nat; _]) -> ClassType
.Tensor!(T, _) <: Output T
.Tensor!(_, _).
    dtype: .DType
    shape: .Size
    view: (|T, Old: [Nat; _], S: {A: [Nat; _] | A.prod() == Old.prod()}|(
        self: .Tensor!(T, Old),
        shape: {S},
    ) -> .Tensor!(T, S)) \
        and (|T|(self: .Tensor!(T, _), shape: [Int; _]) -> .Tensor!(T, _))
    backward!: |T, S: [Nat; _]|(
        self: RefMut(.Tensor!(T, S)),
        gradient := .Tensor!(T, S),
        retain_graph := Bool,
        create_graph := Bool,
    ) => NoneType
    # TODO: S bound
    item: |T|(self: Ref .Tensor!(T, _)) -> T

.relu: |T, S: [Nat; _]|(x: .Tensor!(T, S)) -> .Tensor!(T, S)
